<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DNARoma</title>
    <link>http://dnaroma.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 16 Mar 2020 11:06:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Generating Proto File For Bangdream 4.0.0 (V2)</title>
      <link>http://dnaroma.github.io/2020/03/16/auto-gen-bang-proto-v2/</link>
      <guid>http://dnaroma.github.io/2020/03/16/auto-gen-bang-proto-v2/</guid>
      <pubDate>Mon, 16 Mar 2020 11:06:34 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;You can check &lt;a href=&quot;/2018/09/15/auto-gen-bang-proto/&quot;&gt;this post&lt;/a&gt; for some background. BangDream now use “on demand” 
          
        
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>You can check <a href="/2018/09/15/auto-gen-bang-proto/">this post</a> for some background. BangDream now use “on demand” delivery and I can get only arm64 blobs now. They are so different with old armv7 instrcutions so I have to rewrite some code to get correct tag numbers.</p><p>At first, use <strong>latest</strong> <code>il2cppdumper</code>, or you may have some errors when running the script. I tried immediately with my old script, and all tag numbers are reported <em>None</em>. It’s pretty annoying but it should have something to do with new instructions of arm64 (aarch64). Now let’s check what happend.</p><h2 id="Disassembly"><a href="#Disassembly" class="headerlink" title="Disassembly"></a>Disassembly</h2><p>Like in armv7, protobuf-net codes are also compiled into two kinds of instructions. Use <code>UserAuthRequest</code> as an example. <code>userId</code> is compiled into:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08 04 40 F9 E1 03 00 32 E2 03 1F AA 00 01 40 F9 6D 70 78 14</span><br></pre></td></tr></tbody></table></figure><p>With a <a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=08+04+40+F9+E1+03+00+32+E2+03+1F+AA+00+01+40+F9+6D+70+78+14&arch=arm64&endianness=little&dis_with_addr=True&dis_with_raw=True&dis_with_ins=True#disassembly" target="_blank" rel="noopener">online disassembler</a> you can get following instructions:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000000:  08 04 40 F9    ldr x8, [x0, #8]</span><br><span class="line">0x0000000000000004:  E1 03 00 32    orr w1, wzr, #1</span><br><span class="line">0x0000000000000008:  E2 03 1F AA    mov x2, xzr</span><br><span class="line">0x000000000000000c:  00 01 40 F9    ldr x0, [x8]</span><br><span class="line">0x0000000000000010:  6D 70 78 14    b   #0x1e1c1c4</span><br></pre></td></tr></tbody></table></figure><p>and <code>attestationErrorMsg</code> is encoded as:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F3 0F 1E F8 FD 7B 01 A9 FD 43 00 91 08 04 40 F9 21 01 80 52 ...</span><br></pre></td></tr></tbody></table></figure><p>and processed by <a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=F3+0F+1E+F8+FD+7B+01+A9+FD+43+00+91+08+04+40+F9+21+01+80+52&arch=arm64&endianness=little&dis_with_addr=True&dis_with_raw=True&dis_with_ins=True#disassembly" target="_blank" rel="noopener">disassembler</a>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000000:  F3 0F 1E F8    str  x19, [sp, #-0x20]!</span><br><span class="line">0x0000000000000004:  FD 7B 01 A9    stp  x29, x30, [sp, #0x10]</span><br><span class="line">0x0000000000000008:  FD 43 00 91    add  x29, sp, #0x10</span><br><span class="line">0x000000000000000c:  08 04 40 F9    ldr  x8, [x0, #8]</span><br><span class="line">0x0000000000000010:  21 01 80 52    movz w1, #0x9</span><br></pre></td></tr></tbody></table></figure><p>The most important instructions are:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E1 03 00 32    orr w1, wzr, #1</span><br><span class="line"># or</span><br><span class="line">21 01 80 52    movz w1, #0x9</span><br></pre></td></tr></tbody></table></figure><h2 id="Instruction-Encoding"><a href="#Instruction-Encoding" class="headerlink" title="Instruction Encoding"></a>Instruction Encoding</h2><p>But how are the immediate encoded? By checking the <a href="https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile" target="_blank" rel="noopener">reference</a> and the <a href="http://kitoslab-eng.blogspot.com/2012/10/armv8-aarch64-instruction-encoding.html" target="_blank" rel="noopener">instruction encoding</a> I figured out that <code>MOVZ</code> use direct immediate and <code>ORR</code> use bitmask immediate. Although they are aarch64 instructions, both of them use 32 bit immediate.</p><p>The direct immediate is pretty <em>direct</em>, just read the immediate and it’s finished:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x10x 0010 1xxi iiii iiii iiii iiid dddd</span><br></pre></td></tr></tbody></table></figure><p>But how about bitmask immediate? They are like the rotating encoding of immediate in armv7 but have some different. <code>ORR</code> immediate instruction looks like this:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x01x 0010 0Nii iiii iiii iinn nnnd dddd</span><br></pre></td></tr></tbody></table></figure><p><code>N</code> together with first <em>x</em> (as known as <code>sf</code>) refers to bit length (<code>sf==0 AND N==0</code> => 32bit or <code>sf==1</code> => 64bit), first six binary digits of immediate are <code>immr</code> and last six binary digits of immediate are <code>imms</code>. You can find the code to decode bitmask immediate in the arm official reference:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecodeBitMasks()</span></span><br><span class="line"><span class="comment">// ================</span></span><br><span class="line"><span class="comment">// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure</span></span><br><span class="line"></span><br><span class="line">(bits(M), bits(M)) DecodeBitMasks(bit immN, bits(<span class="number">6</span>) imms, bits(<span class="number">6</span>) immr, <span class="keyword">boolean</span> immediate)</span><br><span class="line">  bits(M) tmask, wmask;</span><br><span class="line">  bits(<span class="number">6</span>) levels;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute log2 of element size</span></span><br><span class="line">  <span class="comment">// 2^len must be in range [2, M]</span></span><br><span class="line">  len = HighestSetBit(immN:NOT(imms));</span><br><span class="line">  <span class="keyword">if</span> len < <span class="number">1</span> then UNDEFINED;</span><br><span class="line">  <span class="keyword">assert</span> M >= (<span class="number">1</span> << len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine S, R and S - R parameters</span></span><br><span class="line">  levels = ZeroExtend(Ones(len), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For logical immediates an all-ones value of S is reserved</span></span><br><span class="line">  <span class="comment">// since it would generate a useless all-ones result (many times)</span></span><br><span class="line">  <span class="keyword">if</span> immediate && (imms AND levels) == levels then UNDEFINED;</span><br><span class="line"></span><br><span class="line">  S = UInt(imms AND levels);</span><br><span class="line">  R = UInt(immr AND levels);</span><br><span class="line">  diff = S - R; <span class="comment">// 6-bit subtract with borrow</span></span><br><span class="line">  esize = <span class="number">1</span> << len;</span><br><span class="line">  d = UInt(diff<len-<span class="number">1</span>:<span class="number">0</span>>);</span><br><span class="line"></span><br><span class="line">  welem = ZeroExtend(Ones(S + <span class="number">1</span>), esize);</span><br><span class="line">  telem = ZeroExtend(Ones(d + <span class="number">1</span>), esize);</span><br><span class="line">  wmask = Replicate(ROR(welem, R));</span><br><span class="line">  tmask = Replicate(telem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (wmask, tmask);</span><br></pre></td></tr></tbody></table></figure><p>But it’s pretty hard to understand. <code>LLVM</code> gives <a href="https://github.com/llvm-mirror/llvm/blob/5c95b810cb3a7dee6d49c030363e5bf0bb41427e/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h#L292" target="_blank" rel="noopener">code</a> which is way more clear:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">decodeLogicalImmediate</span><span class="params">(<span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> regSize)</span> </span>{</span><br><span class="line">  <span class="comment">// Extract the N, imms, and immr fields.</span></span><br><span class="line">  <span class="keyword">unsigned</span> N = (val >> <span class="number">12</span>) & <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> immr = (val >> <span class="number">6</span>) & <span class="number">0x3f</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> imms = val & <span class="number">0x3f</span>;</span><br><span class="line"></span><br><span class="line">  assert((regSize == <span class="number">64</span> || N == <span class="number">0</span>) && <span class="string">"undefined logical immediate encoding"</span>);</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">31</span> - countLeadingZeros((N << <span class="number">6</span>) | (~imms & <span class="number">0x3f</span>));</span><br><span class="line">  assert(len >= <span class="number">0</span> && <span class="string">"undefined logical immediate encoding"</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="built_in">size</span> = (<span class="number">1</span> << len);</span><br><span class="line">  <span class="keyword">unsigned</span> R = immr & (<span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> S = imms & (<span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">  assert(S != <span class="built_in">size</span> - <span class="number">1</span> && <span class="string">"undefined logical immediate encoding"</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> pattern = (<span class="number">1U</span>LL << (S + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i < R; ++i)</span><br><span class="line">    pattern = ror(pattern, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replicate the pattern to fill the regSize.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">size</span> != regSize) {</span><br><span class="line">    pattern |= (pattern << <span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">size</span> *= <span class="number">2</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> pattern;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>OK we can now rewrite our code to get correct tag number.</p><h2 id="New-getTag-Function"><a href="#New-getTag-Function" class="headerlink" title="New getTag Function"></a>New <code>getTag</code> Function</h2><p>Attention that in following code we use <strong>Little-Endian</strong>. In our case, <code>N</code> and <code>sf</code> always equal to 0 so we don’t have to care about length, it’s fixed to 32 bits.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTag</span><span class="params">(address)</span>:</span></span><br><span class="line">  offset = address & <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line">  prog.seek(offset)</span><br><span class="line">  inst = prog.read(<span class="number">4</span>)</span><br><span class="line">  inst = int.from_bytes(inst, byteorder=<span class="string">'little'</span>, signed=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">if</span> inst == <span class="number">0xf9400408</span>:</span><br><span class="line">    prog.seek(offset + <span class="number">4</span>)</span><br><span class="line">    inst = int.from_bytes(prog.read(<span class="number">4</span>), <span class="string">'little'</span>, signed=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">elif</span> inst == <span class="number">0xf81e0ff3</span>:</span><br><span class="line">    prog.seek(offset + <span class="number">16</span>)</span><br><span class="line">    inst = int.from_bytes(prog.read(<span class="number">4</span>), <span class="string">'little'</span>, signed=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(hex(inst), hex(address))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  <span class="keyword">if</span> inst >> <span class="number">24</span> == <span class="number">0x52</span>:</span><br><span class="line">    <span class="keyword">return</span> (inst >> <span class="number">5</span>) & <span class="number">0xFFFF</span></span><br><span class="line">  <span class="keyword">elif</span> inst >> <span class="number">24</span> == <span class="number">0x32</span>:</span><br><span class="line">    retnum = (inst >> <span class="number">8</span>) & <span class="number">0xFFFF</span></span><br><span class="line">    immr = (retnum >> <span class="number">8</span>) & <span class="number">0x3F</span></span><br><span class="line">    imms = (retnum >> <span class="number">2</span>) & <span class="number">0x3F</span></span><br><span class="line">    clz = <span class="keyword">lambda</span> x: <span class="string">"{:032b}"</span>.format(x).index(<span class="string">"1"</span>)</span><br><span class="line">    _len = <span class="number">31</span> - clz((<span class="number">0</span> << <span class="number">6</span>) | (~imms & <span class="number">0x3F</span>))</span><br><span class="line">    _size = <span class="number">1</span> << _len</span><br><span class="line">    R = immr & (_size - <span class="number">1</span>)</span><br><span class="line">    S = imms & (_size - <span class="number">1</span>)</span><br><span class="line">    ret = (<span class="number">1</span> << (S+<span class="number">1</span>)) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(immr):</span><br><span class="line">      ret = rotr(ret, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></tbody></table></figure><p>For whole code please see <a href="https://gist.github.com/dnaroma/1bfc901d95f777a340fcb615d6a96bd3#file-genproto_arm64-py" target="_blank" rel="noopener">this gist</a>.</p><p>Happy hacking!</p></body></html>]]></content:encoded>
      
      <comments>http://dnaroma.github.io/2020/03/16/auto-gen-bang-proto-v2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://dnaroma.github.io/2020/01/08/hello-world/</link>
      <guid>http://dnaroma.github.io/2020/01/08/hello-world/</guid>
      <pubDate>Wed, 08 Jan 2020 16:28:13 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href
          
        
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p></body></html>]]></content:encoded>
      
      <comments>http://dnaroma.github.io/2020/01/08/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Generating Proto File For Bangdream</title>
      <link>http://dnaroma.github.io/2018/09/15/auto-gen-bang-proto/</link>
      <guid>http://dnaroma.github.io/2018/09/15/auto-gen-bang-proto/</guid>
      <pubDate>Sat, 15 Sep 2018 12:04:21 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This post is encouraged by &lt;a href=&quot;https://estertion.win/2018/04/bang-dream-proto%E7%9B%B8%E5%85%B3/&quot; target=&quot;_blank&quot; rel
          
        
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>This post is encouraged by <a href="https://estertion.win/2018/04/bang-dream-proto%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">esterTion’s post</a>. Before I only extract the proto file by hand, but it gives me a easy way to automation. For what is <em>proto file</em> and <em>protobuf</em>, please check <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Google’s documentation</a></p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Bangdream (Full name: BanG Dream! Girls Band Party!, Japanese: バンドリ！ ガールズバンドパーティ！) is a rhythm card game released by Bushiroad and developed by Craftegg with Unity. As of today, Unity is becoming more and more popular among game developers. In Unity 4.x.x, there’s nearly no protection to C# source code. With <a href="https://github.com/0xd4d/dnSpy" target="_blank" rel="noopener">dnSpy</a> or <a href="https://github.com/icsharpcode/ILSpy" target="_blank" rel="noopener">ILSpy</a> it’s very easy to read the code or do some hack.</p><p>From Unity 5, a method called “il2cpp” is applied to convert C# bytecode (IL) to native code. If target is Android, a <code>libil2cpp.so</code> can be found under <code>lib</code> directory. Thanks to Perfare’s amazing tool <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">Il2CppDumper</a>, reading the code is as easy as before.</p><p>Il2CppDumper will generate some files, if you don’t want to read source code with IDA, then just get the <code>dump.cs</code> which includes all classes, methods and variables. For game like Bangdream, you can get rich infomations from this file, like AES key and protobuf definitions. I think Craftegg want to avoid unnecessary files, so they use <em>protobuf-net</em> to write protobuf definitions in C# code.</p><h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h2><p>The method name in <code>dump.cs</code> are very reasonable. The protobuf definition is always stored in class like “GetResponse” or “PostRequest” prefixed by API path. So “SuiteMasterGetResponse” is the class storing the protobuf definition of game master data (or game database). By reading the <a href="https://estertion.win/2018/04/bang-dream-proto%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">esterTion’s post</a> and <a href="https://gist.github.com/esterTion/768c646a83a089af9e5fbb83b77a59fc" target="_blank" rel="noopener">gist code</a>, it seems not hard to extract proto file from the protobuf definition in il2cpp file. The only problem is how to get the Tag number, which can only be found in binary file.</p><h3 id="Read-and-rewrite-code"><a href="#Read-and-rewrite-code" class="headerlink" title="Read and rewrite code"></a>Read and rewrite code</h3><p>The original code of esterTion is written in PHP. Firstly it read the <code>dump.cs</code> and extract the basic structure of protobuf then generate the valid “proto2” file. The best parts are the regular expressions extracting the class body and ProtoMemberAttribute (=proto message member), but sadly it can only run in PCRE system (like PHP). In Python some grammar is invalid (subroutine and atomic group), it spent me hours to constructure working regex for Python.</p><p>Now I get the proto file but with all Tags as hex address. The original <code>getTag</code> method is not working. Is the original code wrong? Probably not. esterTion seems to use the Mach-O binary, which has the different code from Android library. It needs some adjustments.</p><h3 id="Get-the-right-Tag"><a href="#Get-the-right-Tag" class="headerlink" title="Get the right Tag"></a>Get the right Tag</h3><p>Let’s open the <code>libil2cpp.so</code> with <a href="https://hexed.it/" target="_blank" rel="noopener">hex code editor</a> and jump to the address. The hex code for members is like: <code>04 00 90 E5 01 10 A0 E3 ... 04 00 90 E5 02 10 A0 E3 ....</code> One member begins with <code>04 00 90 E5</code>, and the following number keeps changing. Do a verfication and you can find that this is exactly the Tag number you want. Notice that the number is stored in 12 bits, so do not only extract one byte.</p><p>But it’s only one type. Another type begins with <code>10 4C 2D E9</code>, the Tag number is 12 bytes away. So replace the original <code>getTag</code> code with this:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only for Python 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTag</span><span class="params">(address)</span>:</span></span><br><span class="line">  offset = address & <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line">  prog.seek(offset)</span><br><span class="line">  inst = prog.read(<span class="number">4</span>)</span><br><span class="line">  inst = int.from_bytes(inst, byteorder=<span class="string">'little'</span>, signed=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">if</span> inst == <span class="number">0xe5900004</span>: <span class="comment"># caution! little-endian</span></span><br><span class="line">    prog.seek(offset + <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> int.from_bytes(prog.read(<span class="number">2</span>), <span class="string">'little'</span>, signed=<span class="literal">False</span>) & <span class="number">0xfff</span></span><br><span class="line">  <span class="keyword">elif</span> inst == <span class="number">0xe92d4c10</span>: <span class="comment"># caution! little-endian</span></span><br><span class="line">    prog.seek(offset + <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">return</span> int.from_bytes(prog.read(<span class="number">2</span>), <span class="string">'little'</span>, signed=<span class="literal">False</span>) & <span class="number">0xfff</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(hex(inst), hex(address))</span><br></pre></td></tr></tbody></table></figure><blockquote><p>A small problem: the Tag number 300(0x12c) is stored as 3915(0xf4b). Can’t figure out the reason and made a hardcoding.</p></blockquote><h2 id="Proto-supports-map"><a href="#Proto-supports-map" class="headerlink" title="Proto supports map"></a>Proto supports map</h2><p>Proto files now supports map definition, but it will be compiled to a array structure with objects referring the map key and value. For example, the following protos is equivalent:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message test {</span><br><span class="line">  map<uint32, string> entries = 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message testEntry {</span><br><span class="line">  required uint32 key = 1;</span><br><span class="line">  required string value = 2;</span><br><span class="line">}</span><br><span class="line">message test {</span><br><span class="line">  repeated testEntry entries = 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>The original code only supports the second one. The protobuf for Python supports to generate map structure from the first definition. So the first one is optimal for me. Some changes were made to generate the beautiful map definition.</p><h2 id="Final-words"><a href="#Final-words" class="headerlink" title="Final words"></a>Final words</h2><p>You can find the gist code <a href="https://gist.github.com/dnaroma/1bfc901d95f777a340fcb615d6a96bd3" target="_blank" rel="noopener">here</a>. I’ve tested the generated proto file, it fits the game master data. It’s time to say goodbye to manual writting proto file.</p></body></html>]]></content:encoded>
      
      <comments>http://dnaroma.github.io/2018/09/15/auto-gen-bang-proto/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
